=============================
Adding new calculation styles
=============================

The basic steps associated with implementing a new calculation style in iprPy
are

#. Create a new subdirectory in iprPy/calculation named for the new calculation
   style.  For the style name, use lowercase letters except where important and
   separate words with underscores.  The name should be clear and distinct as
   to what the calculation does.

#. Create the calculation script calc\_[style].py within the calculation
   style directory.

#. Add the Python function(s) that perform the calculation to the calculation
   script.

#. Define a process_input() function within the script that generates the
   inputs for the calculation function(s) based on a text input file.

#. If any sets of input keys can or are used by multiple calculation styles and
   are not already collected in a subset style, think about creating one.

#. Add a main() function that calls process_input followed by the calculation
   function(s).  Add the "if \_\_name\_\_ == '\_\_main\_\_':" check that calls
   main() and passes it any command line arguments.

#. Place copies of any other files that the calculation needs (excluding input
   files) in the calculation folder.

#. Create a separate file that defines the Calculation subclass.  Name the file
   after the subclass name, typically by converting the style name to upper
   camel case (each word capitalized with no separators).

#. Define the subclass methods and attributes specific to the calculation
   style.

#. Create an "\_\_init\_\_.py" file that imports the subclass.

#. Create a record style for collecting the calculation results (see
   addrecord documentation).

#. Test single runs of the calculation using Calculation.calc(), and
   Calculation.main() or by running the calculation script.

#. Test preparing the new calculation style for a limited number of conditions.

#. In a terminal, go into one of the prepared calculations in the run directory
   and run the calculation script directly.  Doing this helps check that all
   components of the calculation were properly copied during prepare.

#. Run all of the prepared calculations with runners and check the results.

#. Write documentation for the calculation style in the README.md, theory.md,
   and parameters.md files.  Create an empty calc\_[style].in input file.

Files in the calculation style directories
------------------------------------------

- **calc\_[style].py**: The Python calculation script.

- **calc\_[style].in**: The input file for the calculation with all input keys
  and no values.

- **[Style].py**: Defines the Calculation subclass for the calculation style.
  This defines how the iprPy codebase interacts with the calculation.

- **\_\_init\_\_.py**: Allows Python to identify the calculation directory as
  a sub-package and be able to import the calculation subclass into iprPy.

- **README.md**: A general overview description of the calculation.

- **theory.md**: A detailed description of the calculation theory and
   methodology.

- **parameters.md**: Lists and describes the input parameters recognized by the
  calculation style.

- Copies of any other files required by the calculation.

calc\_[style].py
~~~~~~~~~~~~~~~~

The calculation scripts have a number of components that are common across the
different styles.  This section lists those common components to assist with
the rapid implementation of new calculation styles.

record_style
............

The record style used by the calculation for constructing the results.json file
is listed at the top of the file just before defining the main() function.
While record_style does not need to be a global variable, it is useful to place
it here for clarity.

main()
......

The calculation script's main() function

#. Opens and parses an input parameter file with the iprPy.input.parse()
   function.  This returns a dictionary of the key-value terms, with the values
   as strings.

#. Calls process_input() to interpret the string values of the input dictionary
   as Python values and objects.  The interpreted values are added to the input
   dictionary.

#. Calls the calculation function(s) using the processed terms in the input
   dictionary as input parameters.

#. The formatted results content is generated by passing the input dict and any
   results produced by the calculation function(s) to the record style's
   buildcontent() method.

#. The formatted results content is saved to "results.json".

Calculation function(s)
.......................

The calculation functions are listed next, which take Python objects as
arguments.  All results are returned within a dictionary such that the produced
values can be accessed by name.

process_input()
...............

The process_input() function is defined next, which processes the string input
values contained within an input dictionary, and assigns default values for any
parameters that were not included in the input.  The processed values either
update the values already in the input dictionary, or are added to the
dictionary as new keys.

The function takes the parameters

- input_dict: The dictionary of input values to interpret.

- UUID: The UUID4 calculation key to use.  If not given, a new one will be
  generated.

- build: A boolean flag, which indicates if the function should build all
  objects interpreted from the inputs (True, default), or only those necessary
  to define the calculation (False).  Setting build=False allows for
  process_input() to be used during high-throughput prepare without the
  overhead of creating complex objects that are not used until the calculation
  is executed.

To interpret subset keys similarly across different calculations, use the
Subset.interpret() method for the subset styles you want to include.

For calculation-specific keys, the iprPy.input submodule contains a few
useful functions for interpreting the input files in a common manner.

- iprPy.input.boolean() will interpret (ignoring case sensitivity) 'true',
  't', 'false', and 'f' strings as Python bool values, and will pass
  through values that are already bool.

- iprPy.input.value() can be used to interpret and set default values and
  units for parameters that may include units information, e.g. "5 nm".

Main script option
..................

Finally, the script is told to call the main function if executed directly,
i.e.

.. code-block:: python

    if __name__ == '__main__':
        main(sys.args[1:])

calc\_[style].in
~~~~~~~~~~~~~~~~

The included example input file should list all allowed input keys without any
values assigned.  This allows for another user to simply add the values they
want and run the calculation script for themselves.  This example input script
can be automatically generated using XXX if template is defined
for the Calculation subclass.

[Style].py
~~~~~~~~~~

The iprPy package interacts with the calculation style through the defined
Calculation subclass.  Considerable work has gone into making it easy to
define new subclass definitions by modifying values in pre-existing subclass
definitions.  This section describes the different components of defining a
Calculation subclass.

Inheritance
...........

The class should be a child of iprPy.calculation.Calculation.

\_\_init\_\_()
..............

The \_\_init\_\_() function calls the parent class' \_\_init\_\_() function and
defines which function from the calculation script to assign to the calc()
method.  Note that the parent Calculation class loads the calculation script as
a module, which can be accessed with self.script.

files
.....

The files attribute provides a list of the absolute paths to all files
necessary to run the calculation.  If copied from another Calculation subclass,
only the "files" list defined inside the property function should be changed.
This list should be the file names (without path) of the necessary files
besides the calculation script.

template
........

The template attribute returns a string template of the input file used by the
calculation script.  If copied from another Calculation subclass, the template
will be automatically generated based on the values in the "subsets" and
"runkeys" lists.  The subsets list gives the names of subsets to include keys
for, while the runkeys list gives the calculation-specific input keys.

singularkeys
............

The singularkeys attribute lists all prepare input keys recognized by the
calculation that are limited to having single values.  This can be generated by
joining subset keysets with a list of calculation-specific keys.

multi keys
..........

The multikeys attribute lists all sets of prepare input keys recognized by the
calculation that can be assigned multiple values.  The key sets can be
generated by joining subset keysets with lists of calculation-specific keys.

\_\_init\_\_.py
~~~~~~~~~~~~~~~

The \_\_init\_\_.py file simply needs to tell Python to include the Calculation
subclass.  For instance, if the subclass is called "Style", then
\_\_init\_\_.py contains

.. code-block:: python

    from .Style import Style
    __all__ = ['Style']
