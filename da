[1mdiff --git a/iprPy/calculation/point_defect_mobility/PointDefectMobility.py b/iprPy/calculation/point_defect_mobility/PointDefectMobility.py[m
[1mnew file mode 100644[m
[1mindex 0000000..46d68d7[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/PointDefectMobility.py[m
[36m@@ -0,0 +1,124 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import (absolute_import, print_function,[m
[32m+[m[32m                        division, unicode_literals)[m
[32m+[m[32mimport os[m
[32m+[m
[32m+[m[32mfrom .. import Calculation[m
[32m+[m
[32m+[m[32mclass PointDefectMobility(Calculation):[m
[32m+[m[32m    """[m
[32m+[m[32m    Class for handling different calculation styles in the same fashion.  The[m
[32m+[m[32m    class defines the common methods and attributes, which are then uniquely[m
[32m+[m[32m    implemented for each style.  The available styles are loaded from the[m
[32m+[m[32m    iprPy.calculations submodule.[m
[32m+[m[32m    """[m
[32m+[m[32m    @property[m
[32m+[m[32m    def files(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        iter of str: Path to each file required by the calculation.[m
[32m+[m[32m        """[m
[32m+[m[32m        files = [[m
[32m+[m[32m                 'calc_' + self.style + '.py',[m
[32m+[m[32m                 'min.template',[m
[32m+[m[32m                ][m
[32m+[m[32m        for i in range(len(files)):[m
[32m+[m[32m            files[i] = os.path.join(self.directory, files[i])[m
[32m+[m[41m        [m
[32m+[m[32m        return files[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def singularkeys(self):[m
[32m+[m[32m        """list: Calculation keys that can have single values during prepare."""[m
[32m+[m[32m        return [[m
[32m+[m[32m                'lammps_command',[m
[32m+[m[32m                'mpi_command',[m
[32m+[m[32m                'length_unit',[m
[32m+[m[32m                'pressure_unit',[m
[32m+[m[32m                'energy_unit',[m
[32m+[m[32m                'force_unit',[m
[32m+[m[32m               ][m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def multikeys(self):[m
[32m+[m[32m        """list: Calculation keys that can have multiple values during prepare."""[m
[32m+[m[32m        return [[m
[32m+[m[32m                   [[m
[32m+[m[32m                    'potential_file',[m
[32m+[m[32m                    'potential_dir',[m
[32m+[m[32m                    'load_file',[m
[32m+[m[32m                    'load_style',[m
[32m+[m[32m                    'family',[m
[32m+[m[32m                    'load_options',[m
[32m+[m[32m                    'symbols',[m
[32m+[m[32m                    'box_parameters',[m
[32m+[m[32m                    'allSymbols',[m
[32m+[m[32m                   ],[m
[32m+[m[32m                   [[m
[32m+[m[32m                    'a_uvw',[m
[32m+[m[32m                    'b_uvw',[m
[32m+[m[32m                    'c_uvw',[m
[32m+[m[32m                    'atomshift',[m
[32m+[m[32m                    'sizemults',[m
[32m+[m[32m                   ],[m
[32m+[m[32m                   [[m
[32m+[m[32m                    'pointdefect_file',[m
[32m+[m[32m                    'pointdefect_type',[m
[32m+[m[32m                    'pointdefect_atype',[m
[32m+[m[32m                    'pointdefect_pos',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect',[m
[32m+[m[32m                    'pointdefect_scale',[m
[32m+[m[32m                    'pointdefect_file_1',[m
[32m+[m[32m                    'pointdefect_type_1',[m
[32m+[m[32m                    'pointdefect_atype_1',[m
[32m+[m[32m                    'pointdefect_pos_1',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_1',[m
[32m+[m[32m                    'pointdefect_scale_1',[m
[32m+[m[32m                    'pointdefect_file_2',[m
[32m+[m[32m                    'pointdefect_type_2',[m
[32m+[m[32m                    'pointdefect_atype_2',[m
[32m+[m[32m                    'pointdefect_pos_2',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_2',[m
[32m+[m[32m                    'pointdefect_scale_2',[m
[32m+[m[32m                    'pointdefect_file_3',[m
[32m+[m[32m                    'pointdefect_type_3',[m
[32m+[m[32m                    'pointdefect_atype_3',[m
[32m+[m[32m                    'pointdefect_pos_3',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_3',[m
[32m+[m[32m                    'pointdefect_scale_3',[m
[32m+[m[32m                    'pointdefect_file_4',[m
[32m+[m[32m                    'pointdefect_type_4',[m
[32m+[m[32m                    'pointdefect_atype_4',[m
[32m+[m[32m                    'pointdefect_pos_4',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_4',[m
[32m+[m[32m                    'pointdefect_scale_4',[m
[32m+[m[32m                    'pointdefect_file_5',[m
[32m+[m[32m                    'pointdefect_type_5',[m
[32m+[m[32m                    'pointdefect_atype_5',[m
[32m+[m[32m                    'pointdefect_pos_5',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_5',[m
[32m+[m[32m                    'pointdefect_scale_5',[m
[32m+[m[32m                    'pointdefect_file_6',[m
[32m+[m[32m                    'pointdefect_type_6',[m
[32m+[m[32m                    'pointdefect_atype_6',[m
[32m+[m[32m                    'pointdefect_pos_6',[m
[32m+[m[32m                    'pointdefect_dumbbell_vect_6',[m
[32m+[m[32m                    'pointdefect_scale_6',[m
[32m+[m[32m                    'pointdefect_number',[m
[32m+[m[32m                    'defectpair_number',[m
[32m+[m[32m                    'defectpair_1',[m
[32m+[m[32m                    'defectpair_2',[m
[32m+[m[32m                    'defectpair_3',[m
[32m+[m[32m                    ],[m
[32m+[m[32m                    [[m
[32m+[m[32m                    'energytolerance',[m
[32m+[m[32m                    'forcetolerance',[m
[32m+[m[32m                    'maxatommotion',[m
[32m+[m[32m                    'numberreplicas',[m
[32m+[m[32m                    'springconstant',[m
[32m+[m[32m                    'thermosteps',[m
[32m+[m[32m                    'dumpsteps',[m
[32m+[m[32m                    'timestep',[m
[32m+[m[32m                    'minimumsteps',[m
[32m+[m[32m                    'climbsteps',[m
[32m+[m[32m                    ],[m
[32m+[m[32m               ][m
\ No newline at end of file[m
[1mdiff --git a/iprPy/calculation/point_defect_mobility/__init__.py b/iprPy/calculation/point_defect_mobility/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..824731a[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/__init__.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import division, absolute_import, print_function[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom .PointDefectMobility import PointDefectMobility[m
[32m+[m[32m__all__ = ['PointDefectMobility'][m
[1mdiff --git a/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.py b/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e283607[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.py[m
[36m@@ -0,0 +1,468 @@[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m# Standard library imports[m
[32m+[m[32mfrom __future__ import (absolute_import, print_function,[m
[32m+[m[32m                        division, unicode_literals)[m
[32m+[m[32mimport os[m
[32m+[m[32mimport sys[m
[32m+[m[32mimport uuid[m
[32m+[m[32mimport glob[m
[32m+[m[32mimport shutil[m
[32m+[m[32mimport datetime[m
[32m+[m[32mfrom copy import deepcopy[m
[32m+[m
[32m+[m[32m# http://www.numpy.org/[m
[32m+[m[32mimport numpy as np[m[41m [m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/DataModelDict[m[41m [m
[32m+[m[32mfrom DataModelDict import DataModelDict as DM[m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/atomman[m[41m [m
[32m+[m[32mimport atomman as am[m
[32m+[m[32mimport atomman.lammps as lmp[m
[32m+[m[32mimport atomman.unitconvert as uc[m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/iprPy[m
[32m+[m[32mimport iprPy[m
[32m+[m
[32m+[m[32mimport matplotlib.pyplot as plt[m
[32m+[m
[32m+[m[32mrecord_style = 'calculation_point_defect_mobility'[m
[32m+[m
[32m+[m[32mdef main(*args):[m
[32m+[m[32m    """Main function called when script is executed directly."""[m
[32m+[m[41m    [m
[32m+[m[32m    # Read input file in as dictionary[m
[32m+[m[32m    with open(args[0]) as f:[m
[32m+[m[32m        input_dict = iprPy.input.parse(f, allsingular=True)[m
[32m+[m[41m    [m
[32m+[m[32m    # Interpret and process input parameters[m
[32m+[m[32m    process_input(input_dict, *args[1:])[m
[32m+[m[41m    [m
[32m+[m[32m    d = datetime.datetime.today()[m
[32m+[m[32m    d = d.replace(microsecond=0)[m
[32m+[m[32m    d = d.replace(second=0)[m
[32m+[m[32m    fileNameTime = d.strftime('%Y-%m-%d_%H%M')[m
[32m+[m[32m    fileNameSymbols = ''[m
[32m+[m[32m    for x in input_dict['allSymbols']:[m
[32m+[m[32m        fileNameSymbols = fileNameSymbols+'_'+x[m
[32m+[m[32m    fileName = fileNameTime + fileNameSymbols[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    sourcedir = os.path.join(os.getcwd())[m
[32m+[m[41m    [m
[32m+[m[32m        # If workingdir is already set, then do nothing (already in correct folder)[m
[32m+[m[32m    try:[m
[32m+[m[32m        workingdir = workingdir[m
[32m+[m
[32m+[m[32m    # Change to workingdir if not already there[m
[32m+[m[32m    except:[m
[32m+[m[32m        workingdir = os.path.join(os.getcwd(), 'calculationfiles', record_style)[m
[32m+[m[32m        if not os.path.isdir(workingdir):[m
[32m+[m[32m            os.makedirs(workingdir)[m
[32m+[m[32m        os.chdir(workingdir)[m
[32m+[m
[32m+[m[32m    try:[m
[32m+[m[32m        stroagedir = stroagedir[m
[32m+[m
[32m+[m[32m    # Change to workingdir if not already there[m
[32m+[m[32m    except:[m
[32m+[m[32m        storagedir = os.path.join(workingdir,fileName)[m
[32m+[m[32m        if not os.path.isdir(storagedir):[m
[32m+[m[32m            os.makedirs(storagedir)[m
[32m+[m[32m        os.chdir(storagedir)[m
[32m+[m[41m        [m
[32m+[m[32m    #script = os.path.splitext(os.path.basename(__file__))[0][m
[32m+[m[32m    #print(script)[m
[32m+[m[32m    #record = iprPy.load_record(record_style)[m
[32m+[m[41m    [m
[32m+[m[32m    shutil.copyfile(sourcedir+'\\calc_point_defect_mobility.in', storagedir+'\\calc_point_defect_mobility.in')[m
[32m+[m[41m    [m
[32m+[m[32m    results_dict = DM()[m
[32m+[m[41m    [m
[32m+[m[32m    results_dict['neb_log'] = calc_neb(input_dict['lammps_command'],[m
[32m+[m[32m                            input_dict['initialsystem'],[m
[32m+[m[32m                            input_dict['potential'],[m
[32m+[m[32m                            input_dict['pointdefect_number'],[m
[32m+[m[32m                            input_dict['defectpair_number'],[m
[32m+[m[32m                            input_dict['point_kwargs'],[m
[32m+[m[32m                            input_dict['defect_pairs'],[m
[32m+[m[32m                            input_dict['allSymbols'],[m
[32m+[m[32m                            sourcedir,[m
[32m+[m[32m                            mpi_command = input_dict['mpi_command'],[m
[32m+[m[32m                            etol = input_dict['energytolerance'], #From lammps_min[m
[32m+[m[32m                            ftol = input_dict['forcetolerance'], #From lammps_min[m
[32m+[m[32m                            dmax = input_dict['maxatommotion'], #From lammps_min[m
[32m+[m[32m                            nreplicas = input_dict['numberreplicas'],  #New Thing[m
[32m+[m[32m                            springconst = input_dict['springconstant'], #New Thing[m
[32m+[m[32m                            thermosteps = input_dict['thermosteps'],  #New Thing[m
[32m+[m[32m                            dumpsteps = input_dict['dumpsteps'], #New Thing[m
[32m+[m[32m                            timestep = input_dict['timestep'], #New Thing[m
[32m+[m[32m                            minsteps = input_dict['minsteps'], #New Thing[m
[32m+[m[32m                            climbsteps = input_dict['climbsteps'] #New Thing[m
[32m+[m[32m                            )[m
[32m+[m
[32m+[m[32m#Following are values to parse for in a future interpret function for neb systems[m
[32m+[m
[32m+[m
[32m+[m[32m    neb = lmp.NEBLog()[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    print('There were', neb.nreplicas, 'replicas')[m
[32m+[m[32m    print(neb.minrun)[m
[32m+[m[32m    print(neb.climbrun)[m
[32m+[m[41m    [m
[32m+[m[32m    fig = plt.figure()[m
[32m+[m[41m    [m
[32m+[m[32m    rx, e = neb.get_neb_path(0)[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    results_dict['unrelaxed_run'] = DM()[m[41m [m
[32m+[m[32m    results_dict['unrelaxed_run']['coordinates'] = rx.tolist()[m
[32m+[m[32m    results_dict['unrelaxed_run']['energy'] = e.tolist()[m
[32m+[m[41m    [m
[32m+[m[32m    plt.plot(rx, e, 'o:', label='unrelaxed')[m
[32m+[m
[32m+[m[32m    rx, e = neb.get_neb_path(neb.minrun.Step.values[-1])[m
[32m+[m[41m    [m
[32m+[m[32m    results_dict['final_minimized_run'] = DM()[m[41m [m
[32m+[m[32m    results_dict['final_minimized_run']['coordinates'] = rx.tolist()[m
[32m+[m[32m    results_dict['final_minimized_run']['energy'] = e.tolist()[m
[32m+[m[41m    [m
[32m+[m[32m    plt.plot(rx, e, 'o:',label='after min run')[m
[32m+[m
[32m+[m[32m    rx, e = neb.get_neb_path(neb.climbrun.Step.values[-1])[m
[32m+[m[41m    [m
[32m+[m[32m    plt.plot(rx, e, 'o:',label='after climb run')[m
[32m+[m
[32m+[m[32m    results_dict['final_climb_run'] = DM()[m[41m [m
[32m+[m[32m    results_dict['final_climb_run']['coordinates'] = rx.tolist()[m
[32m+[m[32m    results_dict['final_climb_run']['energy'] = e.tolist()[m
[32m+[m
[32m+[m[32m    plt.legend()[m
[32m+[m[41m    [m
[32m+[m[32m    plt.title('Defect Formation energy vs Normalized Migration Coordinate')[m
[32m+[m[32m    plt.xlabel('Migration Coordinate')[m
[32m+[m[32m    plt.ylabel('Change in formation energy (eV)')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    fig.savefig('EnergyvsCoord.png')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    fig2 = plt.figure()[m
[32m+[m[41m    [m
[32m+[m[32m    rx1, e1 = neb.get_neb_path(neb.minrun.Step.values[-1])[m
[32m+[m[32m    rx2, e2 = neb.get_neb_path(neb.climbrun.Step.values[-1])[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    rx = [][m
[32m+[m[32m    e = [][m
[32m+[m[32m    index1 = 0[m
[32m+[m[32m    index2 = 0[m
[32m+[m[41m    [m
[32m+[m[32m    while index2 < len(rx2):[m
[32m+[m[32m        if rx1[index1] < rx2[index2]:[m
[32m+[m[32m            rx.append(rx1[index1])[m
[32m+[m[32m            e.append(e1[index1])[m
[32m+[m[32m            index1 = index1+1[m
[32m+[m[32m        elif rx1[index1] > rx2[index2]:[m
[32m+[m[32m            rx.append(rx2[index2])[m
[32m+[m[32m            e.append(e2[index2])[m
[32m+[m[32m            index2 = index2+1[m
[32m+[m[32m        elif rx1[index1]==rx2[index1]:[m
[32m+[m[32m            rx.append(rx1[index1])[m
[32m+[m[32m            e.append(e1[index1])[m
[32m+[m[32m            index1 = index1+1[m
[32m+[m[32m            index2 = index2+1[m
[32m+[m[41m    [m
[32m+[m[32m    results_dict['min_and_climb_run'] = DM()[m[41m [m
[32m+[m[32m    results_dict['min_and_climb_run']['coordinates'] = rx[m
[32m+[m[32m    results_dict['min_and_climb_run']['energy'] = e[m
[32m+[m[41m    [m
[32m+[m[32m    plt.plot(rx, e, 'o:',label='Min and Climb Run Combined')[m
[32m+[m[32m    plt.legend()[m
[32m+[m[41m    [m
[32m+[m[32m    plt.title('Defect Formation energy vs Normalized Migration Coordinate')[m
[32m+[m[32m    plt.xlabel('Migration Coordinate')[m
[32m+[m[32m    plt.ylabel('Change in formation energy (eV)')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    fig2.savefig('min_climb_combined.png')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    print('Forward barrier =', uc.get_in_units(neb.get_barrier(), 'eV'), 'eV')[m
[32m+[m[32m    print('Reverse barrier =', uc.get_in_units(neb.get_barrier(reverse=True), 'eV'), 'eV')[m
[32m+[m[41m    [m
[32m+[m[32m    script = os.path.splitext(os.path.basename(__file__))[0][m
[32m+[m[41m    [m
[32m+[m[32m    results_dict['barrier'] = DM()[m
[32m+[m[32m    results_dict['barrier']['energy_units'] = 'eV'[m
[32m+[m[32m    results_dict['barrier']['forward_barrier'] = uc.get_in_units(neb.get_barrier(), 'eV')[m
[32m+[m[32m    results_dict['barrier']['reverse_barrier'] = uc.get_in_units(neb.get_barrier(reverse=True), 'eV')[m
[32m+[m[32m    record = iprPy.load_record(record_style)[m
[32m+[m[32m    record.buildcontent(script, input_dict, results_dict)[m
[32m+[m[41m    [m
[32m+[m[32m    with open('results.json', 'w') as f:[m
[32m+[m[32m        record.content.json(fp=f, indent=4)[m
[32m+[m[41m    [m
[32m+[m[32mdef calc_neb(lammps_command, system_info, potential, point_defect_number, defect_pair_number,point_kwargs,[m
[32m+[m[32m             defect_pair_info, allSymbols, sourcedir, mpi_command = None, etol=0.0, ftol=1e-4, dmax =uc.set_in_units(0.01, 'angstrom'),[m
[32m+[m[32m             nreplicas=11, springconst = 5, thermosteps = 100,[m
[32m+[m[32m             dumpsteps = 10000, timestep = 0.01, minsteps = 10000,[m
[32m+[m[32m             climbsteps = 10000):[m
[32m+[m
[32m+[m[32m    #Section for making alterations to the overall simulation structure[m
[32m+[m[41m    [m
[32m+[m[32m    system = system_info[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    for defectIndex in range(int(point_defect_number)):[m
[32m+[m[32m        for pairIndex in range(int(defect_pair_number)):[m
[32m+[m[32m            pairKey = 'defectpair_'+str(pairIndex+1)[m
[32m+[m[32m            startNum = defect_pair_info[pairIndex][0][m
[32m+[m[32m            endNum = defect_pair_info[pairIndex][1][m
[32m+[m[32m            startNum = int(startNum)[m
[32m+[m[32m            endNum = int(endNum)[m
[32m+[m[32m            if ((defectIndex != startNum) and (defectIndex != endNum)):[m
[32m+[m[32m                if point_kwargs[defectIndex]['ptd_type'].lower() == 'v':[m
[32m+[m[32m                    system = am.defect.vacancy(system, pos=point_kwargs[defectIndex]['pos'])[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 'i':[m
[32m+[m[32m                    system = am.defect.interstitial(system, pos=point_kwargs[defectIndex]['pos'],atype = point_kwargs[defectIndex]['atype'])[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 's':[m
[32m+[m[32m                    system = am.defect.substitutional(system, pos=point_kwargs[defectIndex]['pos'],atype = point_kwargs[defectIndex]['atype'])[m
[32m+[m[32m                else:[m
[32m+[m[32m                    system = am.defect.dumbbell(system, pos=point_kwargs[defectIndex]['pos'],db_vect=point_kwargs[defectIndex]['db_vect'])[m
[32m+[m[32m    currentSymbols = [][m
[32m+[m[41m    [m
[32m+[m[32m    for x in range(system.natypes):[m
[32m+[m[32m        currentSymbols.append(allSymbols[x])[m
[32m+[m[41m    [m
[32m+[m[32m    system.symbols = currentSymbols[m
[32m+[m[41m    [m
[32m+[m[32m    start_system = system[m
[32m+[m
[32m+[m[32m    for defectIndex in range(int(point_defect_number)):[m
[32m+[m[32m        for pairIndex in range(int(defect_pair_number)):[m
[32m+[m[32m            pairKey = 'defectpair_'+str(pairIndex+1)[m
[32m+[m[32m            startNum = defect_pair_info[pairIndex][0][m
[32m+[m[32m            endNum = defect_pair_info[pairIndex][1][m
[32m+[m[32m            startNum = int(startNum)[m
[32m+[m[32m            endNum = int(endNum)[m
[32m+[m[32m            if (defectIndex == startNum):[m
[32m+[m[32m                if point_kwargs[defectIndex]['ptd_type'].lower() == 'v':[m
[32m+[m[32m                    start_system = am.defect.vacancy(start_system, pos=point_kwargs[endNum]['pos'])[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 'i':[m
[32m+[m[32m                    start_system = am.defect.interstitial(start_system, pos=point_kwargs[defectIndex]['pos'],atype = point_kwargs[defectIndex]['atype'])[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 'db':[m
[32m+[m[32m                    start_system = am.defect.dumbbell(start_system, pos=point_kwargs[defectIndex]['pos'],db_vect=point_kwargs[defectIndex]['db_vect'])[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 's':[m
[32m+[m[32m                    raise ValueError('substitutional defects are not implemented for this situation')[m
[32m+[m[32m                else:[m
[32m+[m[32m                    raise ValueError('Invalid Defect Type')[m
[32m+[m[41m    [m
[32m+[m[32m    currentSymbols = [][m
[32m+[m[32m    for x in range(start_system.natypes):[m
[32m+[m[32m        currentSymbols.append(allSymbols[x])[m
[32m+[m[32m    start_system.symbols = currentSymbols[m
[32m+[m[32m    start_system_atoms = start_system.atoms[m
[32m+[m[32m    start_natoms = start_system.natoms[m
[32m+[m
[32m+[m[32m    start_system_info = start_system.dump('atom_data', f='init.dat')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    final_system = start_system[m
[32m+[m[32m    movedAtomIndexes = [][m
[32m+[m[32m    for defectIndex in range(int(point_defect_number)):[m
[32m+[m[32m        for pairIndex in range(int(defect_pair_number)):[m
[32m+[m[32m            pairKey = 'defectpair_'+str(pairIndex+1)[m
[32m+[m[32m            startNum = defect_pair_info[pairIndex][0][m
[32m+[m[32m            endNum = defect_pair_info[pairIndex][1][m
[32m+[m[32m            startNum = int(startNum)[m
[32m+[m[32m            endNum = int(endNum)[m
[32m+[m[32m            if (defectIndex == endNum):[m
[32m+[m[32m                if point_kwargs[defectIndex]['ptd_type'].lower() == 'v':[m
[32m+[m[32m                    for x in range(start_natoms):[m
[32m+[m[32m                        xPos = round(start_system_atoms.pos[x,0],3) == round(point_kwargs[startNum]['pos'][0],3)[m
[32m+[m[32m                        yPos = round(start_system_atoms.pos[x,1],3) == round(point_kwargs[startNum]['pos'][1],3)[m
[32m+[m[32m                        zPos = round(start_system_atoms.pos[x,2],3) == round(point_kwargs[startNum]['pos'][2],3)[m
[32m+[m[32m                        if ((xPos and yPos) and zPos):[m
[32m+[m[32m                            final_system.atoms.pos[x] = point_kwargs[endNum]['pos'][m
[32m+[m[32m                            movedAtomIndexes.append(x)[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 'i':[m
[32m+[m[32m                    for x in range(start_natoms):[m
[32m+[m[32m                        xPos = round(start_system_atoms.pos[x,0],3) == round(point_kwargs[startNum]['pos'][0],3)[m
[32m+[m[32m                        yPos = round(start_system_atoms.pos[x,1],3) == round(point_kwargs[startNum]['pos'][1],3)[m
[32m+[m[32m                        zPos = round(start_system_atoms.pos[x,2],3) == round(point_kwargs[startNum]['pos'][2],3)[m
[32m+[m[32m                        if ((xPos and yPos) and zPos):[m
[32m+[m[32m                            final_system.atoms.pos[x] = point_kwargs[endNum]['pos'][m
[32m+[m[32m                            movedAtomIndexes.append(x)[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 'db':[m
[32m+[m[32m                    for x in range(start_natoms):[m
[32m+[m[32m                        xPos = round(start_system_atoms.pos[x,0],3) == round(point_kwargs[startNum]['pos'][0]-point_kwargs[startNum]['db_vect'][0],3)[m
[32m+[m[32m                        yPos = round(start_system_atoms.pos[x,1],3) == round(point_kwargs[startNum]['pos'][1]-point_kwargs[startNum]['db_vect'][1],3)[m
[32m+[m[32m                        zPos = round(start_system_atoms.pos[x,2],3) == round(point_kwargs[startNum]['pos'][2]-point_kwargs[startNum]['db_vect'][2],3)[m
[32m+[m[32m                        if ((xPos and yPos) and zPos):[m
[32m+[m[32m                            final_system.atoms.pos[x] = point_kwargs[startNum]['pos'][m
[32m+[m[32m                            movedAtomIndexes.append(x)[m
[32m+[m[32m                    for y in range(start_natoms):[m
[32m+[m[32m                        xPos = round(start_system_atoms.pos[y,0],3) == round(point_kwargs[startNum]['pos'][0]+point_kwargs[startNum]['db_vect'][0],3)[m
[32m+[m[32m                        yPos = round(start_system_atoms.pos[y,1],3) == round(point_kwargs[startNum]['pos'][1]+point_kwargs[startNum]['db_vect'][1],3)[m
[32m+[m[32m                        zPos = round(start_system_atoms.pos[y,2],3) == round(point_kwargs[startNum]['pos'][2]+point_kwargs[startNum]['db_vect'][2],3)[m
[32m+[m[32m                        if ((xPos and yPos) and zPos):[m
[32m+[m[32m                            final_system.atoms.pos[y] = point_kwargs[endNum]['pos']-point_kwargs[endNum]['db_vect'][m
[32m+[m[32m                            movedAtomIndexes.append(y)[m
[32m+[m[32m                    for z in range(start_natoms):[m
[32m+[m[32m                        xPos = round(start_system_atoms.pos[z,0],3) == round(point_kwargs[endNum]['pos'][0],3)[m
[32m+[m[32m                        yPos = round(start_system_atoms.pos[z,1],3) == round(point_kwargs[endNum]['pos'][1],3)[m
[32m+[m[32m                        zPos = round(start_system_atoms.pos[z,2],3) == round(point_kwargs[endNum]['pos'][2],3)[m
[32m+[m[32m                        if ((xPos and yPos) and zPos):[m
[32m+[m[32m                            final_system.atoms.pos[z] = point_kwargs[endNum]['pos']+point_kwargs[endNum]['db_vect'][m
[32m+[m[32m                            movedAtomIndexes.append(z)[m
[32m+[m[32m                elif point_kwargs[defectIndex]['ptd_type'].lower() == 's':[m
[32m+[m[32m                    raise ValueError('substitutional defects are not implemented for this situation')[m
[32m+[m[32m                else:[m[41m   [m
[32m+[m[32m                    raise ValueError('Invalid Defect Type')[m
[32m+[m[41m    [m
[32m+[m[32m    final_system_pos = final_system.atoms.pos[movedAtomIndexes][m
[32m+[m[32m    movedAtomIds = [x+1 for x in movedAtomIndexes][m
[32m+[m
[32m+[m[32m    with open('final.dat', 'w') as f:[m
[32m+[m[32m        f.write('%i\n' % len(movedAtomIds))[m
[32m+[m[32m        for x in range(len(movedAtomIds)):[m
[32m+[m[32m            f.write('%i ' % movedAtomIds[x])[m
[32m+[m[32m            for y in range(len(final_system_pos[x])):[m
[32m+[m[32m                f.write('%.13f ' % final_system_pos[x][y])[m
[32m+[m[32m            f.write('\n')[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    # Get lammps units[m
[32m+[m[32m    lammps_units = lmp.style.unit(potential.units)[m
[32m+[m[41m    [m
[32m+[m[32m    #Get lammps version date[m
[32m+[m[32m    lammps_date = lmp.checkversion(lammps_command)['date'][m
[32m+[m[41m    [m
[32m+[m[32m    # Define lammps variables[m
[32m+[m[32m    lammps_terms = {}[m
[32m+[m[32m    lammps_terms['nreplicas'] = nreplicas[m
[32m+[m[32m    lammps_terms['springconst'] = springconst[m
[32m+[m[32m    lammps_terms['thermosteps'] = thermosteps[m
[32m+[m[32m    lammps_terms['dumpsteps'] = dumpsteps[m
[32m+[m[32m    lammps_terms['timestep'] = timestep[m
[32m+[m[32m    lammps_terms['minsteps'] = minsteps[m
[32m+[m[32m    lammps_terms['climbsteps'] = climbsteps[m
[32m+[m[32m    lammps_terms['dmax'] = dmax[m
[32m+[m[32m    lammps_terms['etol'] = etol[m
[32m+[m[32m    lammps_terms['ftol'] = ftol[m
[32m+[m[32m    lammps_terms['atomman_system_info'] = start_system_info[m
[32m+[m[32m    lammps_terms['atomman_pair_info'] = potential.pair_info(start_system.symbols)[m
[32m+[m[32m    lammps_terms['final_system'] = 'final.dat'[m
[32m+[m[41m    [m
[32m+[m[32m    # Write lammps input script[m
[32m+[m[32m    template_file = sourcedir+'\\neb_lammps.template'[m
[32m+[m[32m    input_file = 'neb_lammps.in'[m
[32m+[m[32m    with open(template_file) as f:[m
[32m+[m[32m        template = f.read()[m
[32m+[m
[32m+[m[32m    with open(input_file, 'w') as f:[m
[32m+[m[32m        f.write(am.tools.filltemplate(template, lammps_terms, '<', '>'))[m
[32m+[m[41m        [m
[32m+[m[32m    output = lmp.run(lammps_command, 'neb_lammps.in', mpi_command=mpi_command)[m
[32m+[m[32m    neb = lmp.NEBLog()[m
[32m+[m[41m    [m
[32m+[m[32m    return neb[m
[32m+[m
[32m+[m[32mdef process_input(input_dict, UUID=None, build=True):[m
[32m+[m[32m    """[m
[32m+[m[32m    Processes str input parameters, assigns default values if needed, and[m
[32m+[m[32m    generates new, more complex terms as used by the calculation.[m
[32m+[m[41m    [m
[32m+[m[32m    Parameters[m
[32m+[m[32m    ----------[m
[32m+[m[32m    input_dict :  dict[m
[32m+[m[32m        Dictionary containing the calculation input parameters with string[m
[32m+[m[32m        values.  The allowed keys depends on the calculation style.[m
[32m+[m[32m    UUID : str, optional[m
[32m+[m[32m        Unique identifier to use for the calculation instance.  If not[m[41m [m
[32m+[m[32m        given and a 'UUID' key is not in input_dict, then a random UUID4[m[41m [m
[32m+[m[32m        hash tag will be assigned.[m
[32m+[m[32m    build : bool, optional[m
[32m+[m[32m        Indicates if all complex terms are to be built.  A value of False[m
[32m+[m[32m        allows for default values to be assigned even if some inputs[m[41m [m
[32m+[m[32m        required by the calculation are incomplete.  (Default is True.)[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    # Set calculation UUID[m
[32m+[m[32m    if UUID is not None:[m
[32m+[m[32m        input_dict['calc_key'] = UUID[m
[32m+[m[32m    else:[m
[32m+[m[32m        input_dict['calc_key'] = input_dict.get('calc_key', str(uuid.uuid4()))[m
[32m+[m[41m    [m
[32m+[m[32m    # Set default input/output units[m
[32m+[m[32m    iprPy.input.interpret('units', input_dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # These are calculation-specific default strings[m
[32m+[m[32m    input_dict['sizemults'] = input_dict.get('sizemults', '5 5 5')[m
[32m+[m[32m    input_dict['forcetolerance'] = input_dict.get('forcetolerance',[m
[32m+[m[32m                                                  '1.0e-6 eV/angstrom')[m
[32m+[m[32m    input_dict['numberreplicas'] = input_dict.get('numberreplicas', '11')[m
[32m+[m[32m    input_dict['springconst'] = input_dict.get('numberreplicas', '5')[m
[32m+[m[32m    input_dict['thermosteps'] = input_dict.get('thermosteps','100')[m
[32m+[m[32m    input_dict['timestep'] = input_dict.get('timestep', '0.01')[m
[32m+[m[32m    input_dict['dumpsteps'] = input_dict.get('dumpsteps', '10000')[m
[32m+[m[32m    input_dict['minsteps'] = input_dict.get('minimumsteps', '10000')[m
[32m+[m[32m    input_dict['climbsteps'] = input_dict.get('climbsteps', '10000')[m
[32m+[m[41m    [m
[32m+[m[32m    # These are calculation-specific default booleans[m
[32m+[m[32m    # None for this calculation[m
[32m+[m[41m    [m
[32m+[m[32m    # These are calculation-specific default integers[m
[32m+[m[32m    # input_dict['key'] = int(input_dict.get('key', default))[m
[32m+[m[32m    # None for this calculation[m
[32m+[m[41m    [m
[32m+[m[32m    # These are calculation-specific default unitless floats[m
[32m+[m[32m    # None for this calculation[m
[32m+[m[41m    [m
[32m+[m[32m    # These are calculation-specific default floats with units[m
[32m+[m[32m    # None for this calculation[m
[32m+[m[41m    [m
[32m+[m[32m    #Using lammps_minimize to gather most of the information about[m
[32m+[m[32m    iprPy.input.interpret('lammps_minimize', input_dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # Check lammps_command and mpi_command[m
[32m+[m[32m    iprPy.input.interpret('lammps_commands', input_dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # Load potential[m
[32m+[m[32m    iprPy.input.interpret('lammps_potential', input_dict)[m
[32m+[m[41m    [m
[32m+[m[32m    # Load the initial system[m
[32m+[m[32m    iprPy.input.interpret('atomman_systemload', input_dict, build=build)[m
[32m+[m[41m    [m
[32m+[m[32m    # Construct initialsystem by manipulating ucell system[m
[32m+[m[32m    iprPy.input.interpret('atomman_systemmanipulate', input_dict, build=build)[m
[32m+[m[41m    [m
[32m+[m[32m    #Using pointdefect to define initial and final positions for atoms in the strucutre[m
[32m+[m[41m    [m
[32m+[m[32m    iprPy.input.interpret('pointdefect', input_dict, build=build)[m
[32m+[m
[32m+[m[32m    input_dict['defectpair_number'] = input_dict.get('defectpair_number', '0')[m
[32m+[m[41m    [m
[32m+[m[32m    if int(input_dict['defectpair_number']) > 0:[m
[32m+[m[32m        defect_pairs = {}[m
[32m+[m[32m        input_dict['defect_pairs']={}[m
[32m+[m[32m        for y in range(int(input_dict['defectpair_number'])):[m
[32m+[m[32m            pairKey = 'defectpair_'+str(y+1)[m
[32m+[m[32m            defect_pairs[pairKey] = input_dict.get(pairKey)[m
[32m+[m[32m            input_dict['defect_pairs'][y] = {}[m
[32m+[m[32m            input_dict['defect_pairs'][y][0],input_dict['defect_pairs'][y][1] = defect_pairs[pairKey].split(' ')[m
[32m+[m[32m    else:[m
[32m+[m[32m        input_dict['defect_pairs'] = None[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    input_dict['allSymbols'] = input_dict.get('allSymbols', input_dict['symbols']).split(' ')[m
[32m+[m[41m            [m
[32m+[m[32mif __name__ == '__main__':[m
[32m+[m[32m    main(*sys.argv[1:])[m
[1mdiff --git a/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.template b/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.template[m
[1mnew file mode 100644[m
[1mindex 0000000..eb3a070[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/calc_point_defect_mobility.template[m
[36m@@ -0,0 +1,90 @@[m
[32m+[m[32m# Input script with settings for calc_neb.py[m
[32m+[m
[32m+[m[32m#Command Lines for LAMMPS (and MPI)[m
[32m+[m[32mlammps_command              <lammps_command>[m
[32m+[m[32mmpi_command                 <mpi_command>[m
[32m+[m
[32m+[m[32m# Potential definition and directory containing associated files[m
[32m+[m[32mpotential_file              <potential_file>[m
[32m+[m[32mpotential_dir               <potential_dir>[m
[32m+[m
[32m+[m[32m# Initial system configuration to load[m
[32m+[m[32mload_file                   <load_file>[m
[32m+[m[32mload_style                  <load_style>[m
[32m+[m[32mload_options                <load_options>[m
[32m+[m[32mfamily                      <family>[m
[32m+[m[32msymbols                     <symbols>[m
[32m+[m[32mbox_parameters              <box_parameters>[m
[32m+[m
[32m+[m[32m# System manipulations[m
[32m+[m[32ma_uvw                       <a_uvw>[m
[32m+[m[32mb_uvw                       <b_uvw>[m
[32m+[m[32mc_uvw                       <c_uvw>[m
[32m+[m[32matomshift                   <atomshift>[m
[32m+[m[32msizemults                   <sizemults>[m
[32m+[m
[32m+[m[32m# Defect parameters - use for a single defect or a defect file[m
[32m+[m[32mpointdefect_file            <pointdefect_file>[m
[32m+[m[32mpointdefect_type            <pointdefect_type>[m
[32m+[m[32mpointdefect_atype           <pointdefect_atype>[m
[32m+[m[32mpointdefect_pos             <pointdefect_pos>[m
[32m+[m[32mpointdefect_dumbbell_vect   <pointdefect_dumbbell_vect>[m
[32m+[m[32mpointdefect_scale           <pointdefect_scale>[m
[32m+[m
[32m+[m[32m# Manual defect inputs - use for the addition of a large number of inputs[m
[32m+[m
[32m+[m[32mpointdefect_type_1            <pointdefect_type_1>[m
[32m+[m[32mpointdefect_atype_1           <pointdefect_atype_1>[m
[32m+[m[32mpointdefect_pos_1             <pointdefect_pos_1>[m
[32m+[m[32mpointdefect_dumbbell_vect_1   <pointdefect_dumbbell_vect_1>[m
[32m+[m[32mpointdefect_scale_1           <pointdefect_scale_1>[m
[32m+[m
[32m+[m[32mpointdefect_type_2            <pointdefect_type_2>[m
[32m+[m[32mpointdefect_atype_2           <pointdefect_atype_2>[m
[32m+[m[32mpointdefect_pos_2             <pointdefect_pos_2>[m
[32m+[m[32mpointdefect_dumbbell_vect_2   <pointdefect_dumbbell_vect_2>[m
[32m+[m[32mpointdefect_scale_2           <pointdefect_scale_2>[m
[32m+[m
[32m+[m[32mpointdefect_type_3            <pointdefect_type_3>[m
[32m+[m[32mpointdefect_atype_3           <pointdefect_atype_3>[m
[32m+[m[32mpointdefect_pos_3             <pointdefect_pos_3>[m
[32m+[m[32mpointdefect_dumbbell_vect_3   <pointdefect_dumbbell_vect_3>[m
[32m+[m[32mpointdefect_scale_3           <pointdefect_scale_3>[m
[32m+[m
[32m+[m[32mpointdefect_type_4            <pointdefect_type_4>[m
[32m+[m[32mpointdefect_atype_4           <pointdefect_atype_4>[m
[32m+[m[32mpointdefect_pos_4             <pointdefect_pos_4>[m
[32m+[m[32mpointdefect_dumbbell_vect_4   <pointdefect_dumbbell_vect_4>[m
[32m+[m[32mpointdefect_scale_4           <pointdefect_scale_4>[m
[32m+[m
[32m+[m[32mpointdefect_type_5            <pointdefect_type_5>[m
[32m+[m[32mpointdefect_atype_5           <pointdefect_atype_5>[m
[32m+[m[32mpointdefect_pos_5             <pointdefect_pos_5>[m
[32m+[m[32mpointdefect_dumbbell_vect_5   <pointdefect_dumbbell_vect_5>[m
[32m+[m[32mpointdefect_scale_5           <pointdefect_scale_5>[m
[32m+[m
[32m+[m[32mpointdefect_type_6            <pointdefect_type_6>[m
[32m+[m[32mpointdefect_atype_6           <pointdefect_atype_6>[m
[32m+[m[32mpointdefect_pos_6             <pointdefect_pos_6>[m
[32m+[m[32mpointdefect_dumbbell_vect_6   <pointdefect_dumbbell_vect_6>[m
[32m+[m[32mpointdefect_scale_6           <pointdefect_scale_6>[m
[32m+[m
[32m+[m[32m# Units for input/output values[m
[32m+[m[32mlength_unit                 <length_unit>[m
[32m+[m[32mpressure_unit               <pressure_unit>[m
[32m+[m[32menergy_unit                 <energy_unit>[m
[32m+[m[32mforce_unit                  <force_unit>[m
[32m+[m
[32m+[m[32m# Values parsed by lammps_minimize[m
[32m+[m[32menergytolerance             <energytolerance>[m
[32m+[m[32mforcetolerance              <forcetolerance>[m[41m  [m
[32m+[m[32mmaxatommotion               <maxatommotion>[m
[32m+[m
[32m+[m[32m# NEB Calculation parameters[m
[32m+[m[32mnumberreplicas              <numberreplicas>[m
[32m+[m[32mspringconstant              <springconstant>[m
[32m+[m[32mthermosteps                 <thermosteps>[m
[32m+[m[32mdumpsteps                   <dumpsteps>[m
[32m+[m[32mtimestep                    <timestep>[m
[32m+[m[32mminimumsteps                <minimumsteps>[m
[32m+[m[32mclimbsteps                  <climbsteps>[m
[1mdiff --git a/iprPy/calculation/point_defect_mobility/min.template b/iprPy/calculation/point_defect_mobility/min.template[m
[1mnew file mode 100644[m
[1mindex 0000000..cc43a42[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/min.template[m
[36m@@ -0,0 +1,19 @@[m
[32m+[m[32m# LAMMPS input script that performs a simple energy minimization[m
[32m+[m
[32m+[m[32mbox tilt large[m
[32m+[m
[32m+[m[32m<atomman_system_info>[m
[32m+[m
[32m+[m[32m<atomman_pair_info>[m
[32m+[m
[32m+[m[32mthermo_style custom step lx ly lz pxx pyy pzz pe[m
[32m+[m[32mthermo_modify format float %.13e[m
[32m+[m
[32m+[m[32mcompute peatom all pe/atom[m[41m [m
[32m+[m
[32m+[m[32mdump dumpit all custom <maxeval> atom.* id type x y z c_peatom[m
[32m+[m[32mdump_modify dumpit format <dump_modify_format>[m
[32m+[m
[32m+[m[32mmin_modify dmax <dmax>[m
[32m+[m
[32m+[m[32mminimize <etol> <ftol> <maxiter> <maxeval>[m
\ No newline at end of file[m
[1mdiff --git a/iprPy/calculation/point_defect_mobility/neb_lammps.template b/iprPy/calculation/point_defect_mobility/neb_lammps.template[m
[1mnew file mode 100644[m
[1mindex 0000000..37575f0[m
[1m--- /dev/null[m
[1m+++ b/iprPy/calculation/point_defect_mobility/neb_lammps.template[m
[36m@@ -0,0 +1,51 @@[m
[32m+[m[32m# LAMMPS input script for neb calculations[m
[32m+[m
[32m+[m[32m# NEB parameters[m
[32m+[m[32mvariable nreplicas equal <nreplicas>[m
[32m+[m[32mvariable springconst equal <springconst>[m
[32m+[m
[32m+[m[32m# Run parameters[m
[32m+[m[32mvariable thermosteps equal <thermosteps>[m
[32m+[m[32mvariable dumpsteps equal <dumpsteps>[m
[32m+[m[32mvariable timestep equal <timestep>[m
[32m+[m
[32m+[m[32m# Relaxation parameters[m
[32m+[m[32mvariable minsteps equal <minsteps>[m
[32m+[m[32mvariable climbsteps equal <climbsteps>[m
[32m+[m[32mvariable dmax equal <dmax>[m
[32m+[m[32mvariable etol equal <etol>[m
[32m+[m[32mvariable ftol equal <ftol>[m
[32m+[m
[32m+[m[32m# LAMMPS setting parameters[m
[32m+[m[32mbox tilt large[m
[32m+[m[32matom_modify map array[m
[32m+[m
[32m+[m[32m# initial system definition[m
[32m+[m[32m<atomman_system_info>[m
[32m+[m
[32m+[m[32m# potential definition[m
[32m+[m[32m<atomman_pair_info>[m
[32m+[m
[32m+[m[32m# property compute definitions[m
[32m+[m[32mcompute peatom all pe/atom[m
[32m+[m
[32m+[m[32m# define neb[m
[32m+[m[32mfix neb all neb ${springconst}[m
[32m+[m
[32m+[m[32m# dump file definition[m
[32m+[m[32mvariable i uloop ${nreplicas}[m
[32m+[m[32mdump dumpy all custom ${dumpsteps} step-*.replica-${i}.dump id type x y z c_peatom[m
[32m+[m[32mdump_modify dumpy format float %.13e[m
[32m+[m
[32m+[m[32m# thermo definition[m
[32m+[m[32mthermo ${thermosteps}[m
[32m+[m[32mthermo_style custom step pe[m
[32m+[m[32mthermo_modify format float %.13e[m
[32m+[m
[32m+[m[32m# minimization definition[m
[32m+[m[32mtimestep ${timestep}[m
[32m+[m[32mmin_style quickmin[m
[32m+[m[32mmin_modify dmax ${dmax}[m
[32m+[m
[32m+[m[32m# run neb[m
[32m+[m[32mneb ${etol} ${ftol} ${minsteps} ${climbsteps} ${thermosteps} final <final_system>[m
\ No newline at end of file[m
[1mdiff --git a/iprPy/input/interpret_functions/pointdefectmobility.py b/iprPy/input/interpret_functions/pointdefectmobility.py[m
[1mnew file mode 100644[m
[1mindex 0000000..f367fdf[m
[1m--- /dev/null[m
[1m+++ b/iprPy/input/interpret_functions/pointdefectmobility.py[m
[36m@@ -0,0 +1,308 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import (absolute_import, print_function,[m
[32m+[m[32m                        division, unicode_literals)[m
[32m+[m
[32m+[m[32m# http://www.numpy.org/[m
[32m+[m[32mimport numpy as np[m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/DataModelDict[m
[32m+[m[32mfrom DataModelDict import DataModelDict as DM[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom ..boolean import boolean[m
[32m+[m
[32m+[m[32m__all__ = ['pointdefect'][m
[32m+[m
[32m+[m[32mdef pointdefect(input_dict, build=True, **kwargs):[m
[32m+[m[32m    """[m
[32m+[m[32m    Interprets calculation parameters associated with a point-defect record.[m
[32m+[m[41m    [m
[32m+[m[32m    The input_dict keys used by this function (which can be renamed using the[m
[32m+[m[32m    function's keyword arguments):[m
[32m+[m[41m    [m
[32m+[m[32m    - **'pointdefect_file'** a point-defect record to load.[m
[32m+[m[32m    - **'pointdefect_content'** alternate file or content to load instead of[m
[32m+[m[32m      specified pointdefect_file.  This is used by prepare functions.[m
[32m+[m[32m    - **'pointdefect_model'** The open DataModelDict of the file/content[m
[32m+[m[32m    - **'pointdefect_family'** the crystal family the defect parameters are specified for.[m
[32m+[m[32m    - **'pointdefect_type'** defines the point defect type to add.[m
[32m+[m[32m    - **'pointdefect_atype'** defines the atom type for the defect being[m
[32m+[m[32m      added.[m
[32m+[m[32m    - **'pointdefect_pos'** position to add the defect.[m
[32m+[m[32m    - **'pointdefect_dumbbell_vect'** vector associated with a dumbbell[m
[32m+[m[32m      interstitial.[m
[32m+[m[32m    - **'pointdefect_scale'** indicates if pos and vect terms are scaled or[m
[32m+[m[32m      unscaled.[m
[32m+[m[32m    - **'ucell'** system unit cell. Used for scaling parameters.[m
[32m+[m[32m    - **'calculation_params'** dictionary of point defect terms as read in.[m
[32m+[m[32m    - **'point_kwargs'** dictionary of processed point defect terms as used by[m
[32m+[m[32m      the atomman.defect.point function.[m
[32m+[m[41m       [m
[32m+[m[32m    Parameters[m
[32m+[m[32m    ----------[m
[32m+[m[32m    input_dict : dict[m
[32m+[m[32m        Dictionary containing input parameter key-value pairs.[m
[32m+[m[32m    build : bool[m
[32m+[m[32m        If False, parameters will be interpreted, but objects won't be built[m
[32m+[m[32m        from them (Default is True).[m
[32m+[m[32m    pointdefect_file : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_file'.[m
[32m+[m[32m    pointdefect_content : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_content'.[m
[32m+[m[32m    pointdefect_model : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_model'.[m
[32m+[m[32m    pointdefect_family : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_family'.[m
[32m+[m[32m    pointdefect_type : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_type'.[m
[32m+[m[32m    pointdefect_atype : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_atype'.[m
[32m+[m[32m    pointdefect_pos : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_pos'.[m
[32m+[m[32m    pointdefect_dumbbell_vect : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_dumbbell_vect'.[m
[32m+[m[32m    pointdefect_scale : str[m
[32m+[m[32m        Replacement parameter key name for 'pointdefect_scale'.[m
[32m+[m[32m    ucell : str[m
[32m+[m[32m        Replacement parameter key name for 'ucell'.[m
[32m+[m[32m    calculation_params : str[m
[32m+[m[32m        Replacement parameter key name for 'calculation_params'.[m
[32m+[m[32m    point_kwargs : str[m
[32m+[m[32m        Replacement parameter key name for 'point_kwargs'.[m
[32m+[m[32m    """[m
[32m+[m[41m    [m
[32m+[m[32m    # Set default keynames[m
[32m+[m[32m    keynames = ['pointdefect_mobility_file', 'pointdefect_mobility_model',[m
[32m+[m[32m                'pointdefect_mobility_family', 'ucell', 'initial_calculation_params',[m
[32m+[m[32m                'start_calculation_params','end_calculation_params',[m
[32m+[m[32m                'initialdefect_number','defectpair_number','point_mobility_kwargs'][m
[32m+[m[41m                [m
[32m+[m[32m    for keyname in keynames:[m
[32m+[m[32m        kwargs[keyname] = kwargs.get(keyname, keyname)[m
[32m+[m[41m    [m
[32m+[m[32m    # Extract input values and assign default values[m
[32m+[m[32m    pointdefect_mobility_file = input_dict.get(kwargs['pointdefect_mobility_file'], None)[m
[32m+[m[41m    [m
[32m+[m[41m    [m
[32m+[m[32m    # If defect model is given[m
[32m+[m[32m    if pointdefect_mobility_file is not None:[m
[32m+[m[41m        [m
[32m+[m[41m            [m
[32m+[m[32m        # Load defect model[m
[32m+[m[41m        [m
[32m+[m[32m        pointdefect_mobility_model = DM(pointdefect_mobility_file).find('point-defect-mobility')[m
[32m+[m[32m        input_dict[kwargs['pointdefect_mobility_family']] = pointdefect_mobility_model['system-family'][m
[32m+[m[41m        [m
[32m+[m[32m        #Interpreting premade files here[m
[32m+[m[32m        input_dict['initialdefect_number'] = pointdefect_mobility_model['initial-defect-number'][m
[32m+[m[32m        input_dict['defect_pair_number'] = pointdefect_mobility_model['defect-pair-number'][m
[32m+[m[32m        initial_calculation_params = pointdefect_mobility_model['initial-calculation-parameters'][m
[32m+[m[32m        start_calculation_params = pointdefect_mobility_model['start-calculation-parameters'][m
[32m+[m[32m        end_calculation_params = pointdefect_mobility_model['end-calculation-parameters'][m
[32m+[m[32m        input_dict['allSymbols'] = input_dict.get('allSymbols', input_dict['symbols']).split(' ')[m
[32m+[m[32m        input_dict[kwargs['pointdefect_mobility_model']] = pointdefect_mobility_model[m
[32m+[m
[32m+[m[32m    # Build calculation_params for given values[m
[32m+[m[32m    else:[m
[32m+[m[32m        input_dict['initialdefect_number'] = input_dict.get(kwargs['initialdefect_number'], 0)[m
[32m+[m[32m        input_dict['defect_pair_number'] = input_dict.get(kwargs['defectpair_number'], None)[m
[32m+[m[32m        input_dict['allSymbols'] = input_dict.get('allSymbols', input_dict['symbols']).split(' ')[m
[32m+[m[32m        initial_calculation_params = [][m
[32m+[m[32m        if int(input_dict['initialdefect_number'])>0:[m
[32m+[m[32m            for x in range(int(input_dict['initialdefect_number'])):[m
[32m+[m[32m                defect_type_string = str('initial_pointdefect_type_'+str(x))[m
[32m+[m[32m                defect_atype_string = str('initial_pointdefect_atype_'+str(x))[m
[32m+[m[32m                defect_pos_string = str('initial_pointdefect_pos_'+str(x))[m
[32m+[m[32m                defect_dumbell_string = str('initial_pointdefect_dumbbell_vect_'+str(x))[m
[32m+[m[32m                defect_scale_string = str('initial_pointdefect_scale_'+str(x))[m
[32m+[m[32m                addKeynames = [defect_type_string , defect_atype_string , defect_pos_string , defect_dumbell_string , defect_scale_string][m
[32m+[m[32m                for addKeynames in addKeynames:[m
[32m+[m[32m                    kwargs[addKeynames] = kwargs.get(addKeynames, addKeynames)[m
[32m+[m[32m                newParams= {}[m
[32m+[m[32m                for key1, key2 in zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                               defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                               defect_scale_string),('ptd_type', 'atype', 'pos', 'db_vect',[m
[32m+[m[32m                               'scale')):[m
[32m+[m[32m                    if kwargs[key1] in input_dict:[m
[32m+[m[32m                        newParams[key2] = input_dict[kwargs[key1]][m
[32m+[m[32m                initial_calculation_params.append(newParams)[m
[32m+[m[41m                [m
[32m+[m[32m        if int(input_dict['defect_pair_number']) > 0:[m
[32m+[m[32m            start_calculation_params =[][m
[32m+[m[32m            end_calculation_params=[][m
[32m+[m[32m            for x in range(int(input_dict['defect_pair_number'])):[m
[32m+[m[32m                defect_type_string = str('start_pointdefect_type_'+str(x))[m
[32m+[m[32m                defect_atype_string = str('start_pointdefect_atype_'+str(x))[m
[32m+[m[32m                defect_pos_string = str('start_pointdefect_pos_'+str(x))[m
[32m+[m[32m                defect_dumbell_string = str('start_pointdefect_dumbbell_vect_'+str(x))[m
[32m+[m[32m                defect_scale_string = str('start_pointdefect_scale_'+str(x))[m
[32m+[m[32m                addKeynames = [defect_type_string , defect_atype_string , defect_pos_string , defect_dumbell_string , defect_scale_string][m
[32m+[m[32m                for addKeynames in addKeynames:[m
[32m+[m[32m                    kwargs[addKeynames] = kwargs.get(addKeynames, addKeynames)[m
[32m+[m[32m                newParams= {}[m
[32m+[m[32m                for key1, key2 in zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                               defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                               defect_scale_string),('ptd_type', 'atype', 'pos', 'db_vect',[m
[32m+[m[32m                               'scale')):[m
[32m+[m[32m                    if kwargs[key1] in input_dict:[m
[32m+[m[32m                        newParams[key2] = input_dict[kwargs[key1]][m
[32m+[m[32m                start_calculation_params.append(newParams)[m
[32m+[m[32m            for x in range(int(input_dict['defect_pair_number'])):[m
[32m+[m[32m                defect_type_string = str('end_pointdefect_type_'+str(x))[m
[32m+[m[32m                defect_atype_string = str('end_pointdefect_atype_'+str(x))[m
[32m+[m[32m                defect_pos_string = str('end_pointdefect_pos_'+str(x))[m
[32m+[m[32m                defect_dumbell_string = str('end_pointdefect_dumbbell_vect_'+str(x))[m
[32m+[m[32m                defect_scale_string = str('end_pointdefect_scale_'+str(x))[m
[32m+[m[32m                addKeynames = [defect_type_string , defect_atype_string , defect_pos_string , defect_dumbell_string , defect_scale_string][m
[32m+[m[32m                for addKeynames in addKeynames:[m
[32m+[m[32m                    kwargs[addKeynames] = kwargs.get(addKeynames, addKeynames)[m
[32m+[m[32m                newParams= {}[m
[32m+[m[32m                for key1, key2 in zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                               defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                               defect_scale_string),('ptd_type', 'atype', 'pos', 'db_vect',[m
[32m+[m[32m                               'scale')):[m
[32m+[m[32m                    if kwargs[key1] in input_dict:[m
[32m+[m[32m                        newParams[key2] = input_dict[kwargs[key1]][m
[32m+[m[32m                end_calculation_params.append(newParams)[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m[32m    # Save processed terms[m
[32m+[m
[32m+[m[41m    [m
[32m+[m[32m    input_dict[kwargs['initial_calculation_params']] = initial_calculation_params[m
[32m+[m[32m    input_dict[kwargs['start_calculation_params']] = start_calculation_params[m
[32m+[m[32m    input_dict[kwargs['end_calculation_params']] = end_calculation_params[m
[32m+[m[41m    [m
[32m+[m
[32m+[m[32m    # Build point_kwargs from calculation_params[m
[32m+[m[32m    if build is True:[m
[32m+[m[32m        ucell = input_dict[kwargs['ucell']][m
[32m+[m[32m        if not isinstance(initial_calculation_params, (list, tuple)):[m
[32m+[m[32m            initial_calculation_params = [initial_calculation_params][m
[32m+[m[41m            [m
[32m+[m[32m        if not isinstance(start_calculation_params, (list, tuple)):[m
[32m+[m[32m            start_calculation_params = [start_calculation_params][m
[32m+[m[41m        [m
[32m+[m[32m        if not isinstance(end_calculation_params, (list, tuple)):[m
[32m+[m[32m            end_calculation_params = [end_calculation_params][m
[32m+[m[41m        [m
[32m+[m[32m        # Process parameters for running[m
[32m+[m[32m        point_mobility_kwargs = DM()[m
[32m+[m[32m        point_mobility_kwargs['initial'] = [][m
[32m+[m[32m        point_mobility_kwargs['start'] = [][m
[32m+[m[32m        point_mobility_kwargs['end'] = [][m
[32m+[m
[32m+[m[32m        for raw in initial_calculation_params:[m
[32m+[m[32m            processed = {}[m
[32m+[m[41m            [m
[32m+[m[32m            scale = boolean(raw.get('scale', False))[m
[32m+[m[41m            [m
[32m+[m[32m            if 'ptd_type' in raw:[m
[32m+[m[32m                if   raw['ptd_type'].lower() in ['v', 'vacancy']:[m
[32m+[m[32m                    processed['ptd_type'] = 'v'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['i', 'interstitial']:[m
[32m+[m[32m                    processed['ptd_type'] = 'i'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['s', 'substitutional']:[m
[32m+[m[32m                    processed['ptd_type'] = 's'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['d', 'db', 'dumbbell']:[m
[32m+[m[32m                    processed['ptd_type'] = 'db'[m[41m  [m
[32m+[m[32m                else:[m
[32m+[m[32m                    raise ValueError('invalid ptd_type')[m
[32m+[m[41m            [m
[32m+[m[32m            if 'atype' in raw:[m
[32m+[m[32m                processed['atype'] = int(raw['atype'])[m
[32m+[m[41m                [m
[32m+[m[32m            if 'pos' in raw:[m
[32m+[m[32m                processed['pos'] = np.array(raw['pos'].strip().split(),[m
[32m+[m[32m                                            dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['pos'] = ucell.unscale(processed['pos'])[m
[32m+[m[32m            if 'db_vect' in raw:[m
[32m+[m[41m            [m
[32m+[m[32m                processed['db_vect'] = np.array(raw['db_vect'].strip().split(),[m
[32m+[m[32m                                                dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['db_vect'] = ucell.unscale(processed['db_vect'])[m
[32m+[m[41m            [m
[32m+[m[32m            processed['scale'] = False[m
[32m+[m[41m            [m
[32m+[m[32m            point_mobility_kwargs['initial'].append(processed)[m
[32m+[m[41m        [m
[32m+[m[32m        for raw in start_calculation_params:[m
[32m+[m[32m            processed = {}[m
[32m+[m[41m            [m
[32m+[m[32m            scale = boolean(raw.get('scale', False))[m
[32m+[m[41m            [m
[32m+[m[32m            if 'ptd_type' in raw:[m
[32m+[m[32m                if   raw['ptd_type'].lower() in ['v', 'vacancy']:[m
[32m+[m[32m                    processed['ptd_type'] = 'v'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['i', 'interstitial']:[m
[32m+[m[32m                    processed['ptd_type'] = 'i'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['s', 'substitutional']:[m
[32m+[m[32m                    processed['ptd_type'] = 's'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['d', 'db', 'dumbbell']:[m
[32m+[m[32m                    processed['ptd_type'] = 'db'[m[41m  [m
[32m+[m[32m                else:[m
[32m+[m[32m                    raise ValueError('invalid ptd_type')[m
[32m+[m[41m            [m
[32m+[m[32m            if 'atype' in raw:[m
[32m+[m[32m                processed['atype'] = int(raw['atype'])[m
[32m+[m[41m                [m
[32m+[m[32m            if 'pos' in raw:[m
[32m+[m[32m                processed['pos'] = np.array(raw['pos'].strip().split(),[m
[32m+[m[32m                                            dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['pos'] = ucell.unscale(processed['pos'])[m
[32m+[m[32m            if 'db_vect' in raw:[m
[32m+[m[41m            [m
[32m+[m[32m                processed['db_vect'] = np.array(raw['db_vect'].strip().split(),[m
[32m+[m[32m                                                dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['db_vect'] = ucell.unscale(processed['db_vect'])[m
[32m+[m[41m            [m
[32m+[m[32m            processed['scale'] = False[m
[32m+[m[41m            [m
[32m+[m[32m            point_mobility_kwargs['start'].append(processed)[m
[32m+[m[41m            [m
[32m+[m[32m        for raw in end_calculation_params:[m
[32m+[m[32m            processed = {}[m
[32m+[m[41m            [m
[32m+[m[32m            scale = boolean(raw.get('scale', False))[m
[32m+[m[41m            [m
[32m+[m[32m            if 'ptd_type' in raw:[m
[32m+[m[32m                if   raw['ptd_type'].lower() in ['v', 'vacancy']:[m
[32m+[m[32m                    processed['ptd_type'] = 'v'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['i', 'interstitial']:[m
[32m+[m[32m                    processed['ptd_type'] = 'i'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['s', 'substitutional']:[m
[32m+[m[32m                    processed['ptd_type'] = 's'[m
[32m+[m[32m                elif raw['ptd_type'].lower() in ['d', 'db', 'dumbbell']:[m
[32m+[m[32m                    processed['ptd_type'] = 'db'[m[41m  [m
[32m+[m[32m                else:[m
[32m+[m[32m                    raise ValueError('invalid ptd_type')[m
[32m+[m[41m            [m
[32m+[m[32m            if 'atype' in raw:[m
[32m+[m[32m                processed['atype'] = int(raw['atype'])[m
[32m+[m[41m                [m
[32m+[m[32m            if 'pos' in raw:[m
[32m+[m[32m                processed['pos'] = np.array(raw['pos'].strip().split(),[m
[32m+[m[32m                                            dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['pos'] = ucell.unscale(processed['pos'])[m
[32m+[m[32m            if 'db_vect' in raw:[m
[32m+[m[41m            [m
[32m+[m[32m                processed['db_vect'] = np.array(raw['db_vect'].strip().split(),[m
[32m+[m[32m                                                dtype=float)[m
[32m+[m[32m                if scale is True:[m
[32m+[m[32m                    processed['db_vect'] = ucell.unscale(processed['db_vect'])[m
[32m+[m[41m            [m
[32m+[m[32m            processed['scale'] = False[m
[32m+[m[41m            [m
[32m+[m[32m            point_mobility_kwargs['end'].append(processed)[m
[32m+[m[41m        [m
[32m+[m[32m        # Save processed terms[m
[32m+[m
[32m+[m[32m        input_dict[kwargs['point_mobility_kwargs']] = point_mobility_kwargs[m
[32m+[m[32m    else:[m
[32m+[m[32m        input_dict[kwargs['point_mobility_kwargs']] = None[m
\ No newline at end of file[m
[1mdiff --git a/iprPy/record/calculation_point_defect_mobility/CalculationPointDefectMobility.py b/iprPy/record/calculation_point_defect_mobility/CalculationPointDefectMobility.py[m
[1mnew file mode 100644[m
[1mindex 0000000..b037811[m
[1m--- /dev/null[m
[1m+++ b/iprPy/record/calculation_point_defect_mobility/CalculationPointDefectMobility.py[m
[36m@@ -0,0 +1,411 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import (absolute_import, print_function,[m
[32m+[m[32m                        division, unicode_literals)[m
[32m+[m[32mimport os[m
[32m+[m
[32m+[m[32m# http://www.numpy.org/[m
[32m+[m[32mimport numpy as np[m
[32m+[m
[32m+[m[32m# https://pandas.pydata.org/[m
[32m+[m[32mimport pandas as pd[m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/DataModelDict[m
[32m+[m[32mfrom DataModelDict import DataModelDict as DM[m
[32m+[m
[32m+[m[32m# https://github.com/usnistgov/atomman[m
[32m+[m[32mimport atomman as am[m
[32m+[m[32mimport atomman.lammps as lmp[m
[32m+[m[32mimport atomman.unitconvert as uc[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom ... import __version__ as iprPy_version[m
[32m+[m[32mfrom .. import Record[m
[32m+[m[32mfrom ...tools import aslist[m
[32m+[m
[32m+[m[32mclass CalculationPointDefectMobility(Record):[m
[32m+[m
[32m+[m[32m    @property[m
[32m+[m[32m    def contentroot(self):[m
[32m+[m[32m        """str: The root element of the content"""[m
[32m+[m[32m        return 'calculation-point-defect-static'[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def schema(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        str: The absolute directory path to the .xsd file associated with the[m
[32m+[m[32m             record style.[m
[32m+[m[32m        """[m
[32m+[m[32m        return os.path.join(self.directory, 'record-calculation-point-defect-static.xsd')[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def compare_terms(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        list of str: The default terms used by isnew() for comparisons.[m
[32m+[m[32m        """[m
[32m+[m[32m        return [[m
[32m+[m[32m                'script',[m
[32m+[m[41m                [m
[32m+[m[32m                'load_file',[m
[32m+[m[32m                'load_options',[m
[32m+[m[32m                'symbols',[m
[32m+[m[41m                [m
[32m+[m[32m                'potential_LAMMPS_key',[m
[32m+[m[41m                [m
[32m+[m[32m                'a_mult',[m
[32m+[m[32m                'b_mult',[m
[32m+[m[32m                'c_mult',[m
[32m+[m[41m                [m
[32m+[m[32m                'pointdefect_key',[m
[32m+[m[32m               ][m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def compare_fterms(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        list of str: The default fterms used by isnew() for comparisons.[m
[32m+[m[32m        """[m
[32m+[m[32m        return [][m
[32m+[m[41m    [m
[32m+[m[32m    def isvalid(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        Looks at the values of elements in the record to determine if the[m
[32m+[m[32m        associated calculation would be a valid one to run.[m
[32m+[m[41m        [m
[32m+[m[32m        Returns[m
[32m+[m[32m        -------[m
[32m+[m[32m        bool[m
[32m+[m[32m            True if element combinations are valid, False if not.[m
[32m+[m[32m        """[m
[32m+[m[32m        #NEED TO LOOK AT THIS LATER[m
[32m+[m[32m        #calc = self.content[self.contentroot][m
[32m+[m[32m        #return calc['point-defect']['system-family'] == calc['system-info']['family'][m
[32m+[m[41m    [m
[32m+[m[32m        return [][m
[32m+[m[32m    def buildcontent(self, script, input_dict, results_dict=None):[m
[32m+[m[32m        """[m
[32m+[m[32m        Builds a data model of the specified record style based on input (and[m
[32m+[m[32m        results) parameters.[m
[32m+[m[41m        [m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m[32m        script : str[m
[32m+[m[32m            The name of the calculation script used.[m
[32m+[m[32m        input_dict : dict[m
[32m+[m[32m            Dictionary of all input parameter terms.[m
[32m+[m[32m        results_dict : dict, optional[m
[32m+[m[32m            Dictionary containing any results produced by the calculation.[m
[32m+[m[41m            [m
[32m+[m[32m        Returns[m
[32m+[m[32m        -------[m
[32m+[m[32m        DataModelDict[m
[32m+[m[32m            Data model consistent with the record's schema format.[m
[32m+[m[41m        [m
[32m+[m[32m        Raises[m
[32m+[m[32m        ------[m
[32m+[m[32m        AttributeError[m
[32m+[m[32m            If buildcontent is not defined for record style.[m
[32m+[m[32m        """[m
[32m+[m[32m                # Create the root of the DataModelDict[m
[32m+[m[32m        output = DM()[m
[32m+[m[32m        output[self.contentroot] = calc = DM()[m
[32m+[m[41m        [m
[32m+[m[32m        # Assign uuid[m
[32m+[m[32m        calc['key'] = input_dict['calc_key'][m
[32m+[m[41m        [m
[32m+[m[32m        # Save calculation parameters[m
[32m+[m[32m        calc['calculation'] = DM()[m
[32m+[m[32m        calc['calculation']['iprPy-version'] = iprPy_version[m
[32m+[m[32m        calc['calculation']['atomman-version'] = am.__version__[m
[32m+[m[32m        calc['calculation']['LAMMPS-version'] = input_dict['lammps_version'][m
[32m+[m[41m        [m
[32m+[m[32m        calc['calculation']['script'] = script[m
[32m+[m[32m        calc['calculation']['run-parameter'] = run_params = DM()[m
[32m+[m[41m        [m
[32m+[m[32m        run_params['size-multipliers'] = DM()[m
[32m+[m[32m        run_params['size-multipliers']['a'] = list(input_dict['sizemults'][0])[m
[32m+[m[32m        run_params['size-multipliers']['b'] = list(input_dict['sizemults'][1])[m
[32m+[m[32m        run_params['size-multipliers']['c'] = list(input_dict['sizemults'][2])[m
[32m+[m[41m        [m
[32m+[m[32m        run_params['box-parameters'] = DM()[m
[32m+[m[32m        run_params['box-parameters']['a'] = list(input_dict['box_parameters'][0])[m
[32m+[m[32m        run_params['box-parameters']['b'] = list(input_dict['box_parameters'][1])[m
[32m+[m[32m        run_params['box-parameters']['c'] = list(input_dict['box_parameters'][2])[m
[32m+[m[41m        [m
[32m+[m[32m        run_params['energytolerance'] = input_dict['energytolerance'][m
[32m+[m[32m        run_params['forcetolerance'] = uc.model(input_dict['forcetolerance'],[m[41m [m
[32m+[m[32m                                                input_dict['energy_unit'] + '/'[m[41m [m
[32m+[m[32m                                                + input_dict['length_unit'])[m
[32m+[m[32m        run_params['maxatommotion']  = uc.model(input_dict['maxatommotion'],[m
[32m+[m[32m                                                input_dict['length_unit'])[m
[32m+[m[32m        run_params['numberreplicas'] = input_dict['numberreplicas'][m
[32m+[m[32m        run_params['springconstant'] = input_dict['springconstant'][m
[32m+[m[32m        run_params['thermosteps'] = input_dict['thermosteps'][m
[32m+[m[32m        run_params['dumpsteps'] = input_dict['dumpsteps'][m
[32m+[m[32m        run_params['minimumsteps'] = input_dict['minimumsteps'][m
[32m+[m[32m        run_params['climbsteps'] = input_dict['climbsteps'][m
[32m+[m[32m        run_params['timestep'] = input_dict['timestep'][m
[32m+[m[41m        [m
[32m+[m[32m        # Copy over potential data model info[m
[32m+[m[32m        calc['potential-LAMMPS'] = DM()[m
[32m+[m[32m        calc['potential-LAMMPS']['key'] = input_dict['potential'].key[m
[32m+[m[32m        calc['potential-LAMMPS']['id'] = input_dict['potential'].id[m
[32m+[m[32m        calc['potential-LAMMPS']['potential'] = DM()[m
[32m+[m[32m        calc['potential-LAMMPS']['potential']['key'] = input_dict['potential'].potkey[m
[32m+[m[32m        calc['potential-LAMMPS']['potential']['id'] = input_dict['potential'].potid[m
[32m+[m[41m        [m
[32m+[m[32m        # Save info on system file loaded[m
[32m+[m[32m        calc['system-info'] = DM()[m
[32m+[m[32m        calc['system-info']['family'] = input_dict['family'][m
[32m+[m[32m        calc['system-info']['artifact'] = DM()[m
[32m+[m[32m        calc['system-info']['artifact']['file'] = input_dict['load_file'][m
[32m+[m[32m        calc['system-info']['artifact']['format'] = input_dict['load_style'][m
[32m+[m[32m        calc['system-info']['artifact']['load_options'] = input_dict['load_options'][m
[32m+[m[32m        calc['system-info']['symbol'] = input_dict['symbols'][m
[32m+[m[41m        [m
[32m+[m[32m        # Save Info on the defect parameters[m
[32m+[m[32m        calc['point-defects'] = DM()[m
[32m+[m[32m        calc['point-defects']['numberInitialDefects']= input_dict['initialdefect_number'][m
[32m+[m[32m        calc['point-defects']['numberDefectPairs'] = input_dict['defect_pair_number'][m
[32m+[m
[32m+[m[32m        calc['point-defects']['allSymbols'] = input_dict['allSymbols'][m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[32m        if int(calc['point-defects']['numberInitialDefects']) > 0:[m
[32m+[m[32m            for x in range(int(calc['point-defects']['numberInitialDefects'])):[m
[32m+[m[41m                [m
[32m+[m[32m                pointDefectString = 'initial-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'initial_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'initial_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'initial_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'initial_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'initial_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                calc['point-defects'][pointDefectString]=DM()[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('initial-defect-type', 'initial-defect-atom-type', 'initial-defect-position', 'initial-defect-dumbbell-vector',[m
[32m+[m[32m                                    'initial=defect-scale')):[m
[32m+[m[32m                    if key1 in input_dict:[m
[32m+[m[32m                        calc['point-defects'][pointDefectString][key2]=input_dict[key1][m
[32m+[m
[32m+[m[32m        if int(calc['point-defects']['numberDefectPairs']) > 0:[m
[32m+[m[32m            for x in range(int(calc['point-defects']['numberDefectPairs'])):[m
[32m+[m[41m                [m
[32m+[m[32m                pointDefectString = 'start-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'start_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'start_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'start_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'start_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'start_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                calc['point-defects'][pointDefectString]=DM()[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('start-defect-type', 'start-defect-atom-type', 'start-defect-position', 'start-defect-dumbbell-vector',[m
[32m+[m[32m                                    'start=defect-scale')):[m
[32m+[m[32m                    if key1 in input_dict:[m
[32m+[m[32m                        calc['point-defects'][pointDefectString][key2]=input_dict[key1][m
[32m+[m
[32m+[m[32m        if int(calc['point-defects']['numberDefectPairs']) > 0:[m
[32m+[m[32m            for x in range(int(calc['point-defects']['numberDefectPairs'])):[m
[32m+[m[41m                [m
[32m+[m[32m                pointDefectString = 'end-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'end_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'end_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'end_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'end_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'end_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                calc['point-defects'][pointDefectString]=DM()[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('end-defect-type', 'end-defect-atom-type', 'end-defect-position', 'end-defect-dumbbell-vector',[m
[32m+[m[32m                                    'end-defect-scale')):[m
[32m+[m[32m                    if key1 in input_dict:[m
[32m+[m[32m                        calc['point-defects'][pointDefectString][key2]=input_dict[key1][m
[32m+[m[32m        # Saving The Results[m
[32m+[m
[32m+[m[32m        if results_dict is None:[m
[32m+[m[32m            calc['status'] = 'not calculated'[m
[32m+[m[32m        else:[m
[32m+[m[32m            calc['calculation']['calc-results'] = results = DM()[m
[32m+[m[32m            results['unrelaxed'] = DM()[m
[32m+[m[32m            results['unrelaxed']['coordinates'] = results_dict['unrelaxed_run']['coordinates'][m
[32m+[m[32m            results['unrelaxed']['energy'] = results_dict['unrelaxed_run']['energy'][m
[32m+[m[32m            results['minimized'] = DM()[m
[32m+[m[32m            results['minimized']['coordinates'] = results_dict['final_minimized_run']['coordinates'][m
[32m+[m[32m            results['minimized']['energy'] = results_dict['final_minimized_run']['energy'][m
[32m+[m[32m            results['climbed'] = DM()[m
[32m+[m[32m            results['climbed']['coordinates'] = results_dict['final_climb_run']['coordinates'][m
[32m+[m[32m            results['climbed']['energy'] = results_dict['final_climb_run']['energy'][m
[32m+[m[32m            results['minimized-and-climbed'] = DM()[m
[32m+[m[32m            results['minimized-and-climbed']['coordinates'] = results_dict['min_and_climb_run']['coordinates'][m
[32m+[m[32m            results['minimized-and-climbed']['energy'] = results_dict['min_and_climb_run']['energy'][m
[32m+[m[32m            results['barrier'] = DM()[m
[32m+[m[32m            results['barrier']['energy-units'] = results_dict['barrier']['energy_units'][m
[32m+[m[32m            results['barrier']['forward-barrier'] = results_dict['barrier']['forward_barrier'][m
[32m+[m[32m            results['barrier']['reverse-barrier'] = results_dict['barrier']['reverse_barrier'][m
[32m+[m
[32m+[m[41m        [m
[32m+[m[32m        self.content = output[m
[32m+[m[41m                [m
[32m+[m[32m    def todict(self, full=True, flat=False):[m[41m   [m
[32m+[m[32m        """[m
[32m+[m[32m        Converts the structured content to a simpler dictionary.[m
[32m+[m[41m        [m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m[32m        full : bool, optional[m
[32m+[m[32m            Flag used by the calculation records.  A True value will include[m
[32m+[m[32m            terms for both the calculation's input and results, while a value[m
[32m+[m[32m            of False will only include input terms (Default is True).[m
[32m+[m[32m        flat : bool, optional[m
[32m+[m[32m            Flag affecting the format of the dictionary terms.  If True, the[m
[32m+[m[32m            dictionary terms are limited to having only str, int, and float[m
[32m+[m[32m            values, which is useful for comparisons.  If False, the term[m
[32m+[m[32m            values can be of any data type, which is convenient for analysis.[m
[32m+[m[32m            (Default is False).[m
[32m+[m[41m            [m
[32m+[m[32m        Returns[m
[32m+[m[32m        -------[m
[32m+[m[32m        dict[m
[32m+[m[32m            A dictionary representation of the record's content.[m
[32m+[m[32m        """[m
[32m+[m[41m        [m
[32m+[m[32m        calc = self.content[self.contentroot][m
[32m+[m[32m        params = {}[m
[32m+[m[32m        params['key'] = calc['key'][m
[32m+[m[32m        params['script'] = calc['calculation']['script'][m
[32m+[m[32m        params['iprPy_version'] = calc['calculation']['iprPy-version'][m
[32m+[m[32m        params['LAMMPS_version'] = calc['calculation']['LAMMPS-version'][m
[32m+[m[32m        params['energytolerance']= calc['calculation']['run-parameter']['energytolerance'][m
[32m+[m[32m        params['forcetolerance'] = calc['calculation']['run-parameter']['forcetolerance'][m
[32m+[m[32m        params['maxatommotion'] = calc['calculation']['run-parameter']['maxatommotion'][m
[32m+[m[32m        params['numberreplicas'] = calc['calculation']['run-parameter']['maxatommotion'][m
[32m+[m[32m        params['springconstant'] = calc['calculation']['run-parameter']['springconstant'][m
[32m+[m[32m        params['thermosteps'] = calc['calculation']['run-parameter']['thermosteps'][m
[32m+[m[32m        params['dumpsteps'] = calc['calculation']['run-parameter']['dumpsteps'][m
[32m+[m[32m        params['minimumsteps'] = calc['calculation']['run-parameter']['minimumsteps'][m
[32m+[m[32m        params['climbsteps'] = calc['calculation']['run-parameter']['climbsteps'][m
[32m+[m[32m        params['timestep'] = calc['calculation']['run-parameter']['timestep'][m
[32m+[m[41m        [m
[32m+[m[32m        sizemults = calc['calculation']['run-parameter']['size-multipliers'][m
[32m+[m[41m        [m
[32m+[m[32m        params['potential_LAMMPS_key'] = calc['potential-LAMMPS']['key'][m
[32m+[m[32m        params['potential_LAMMPS_id'] = calc['potential-LAMMPS']['id'][m
[32m+[m[32m        params['potential_key'] = calc['potential-LAMMPS']['potential']['key'][m
[32m+[m[32m        params['potential_id'] = calc['potential-LAMMPS']['potential']['id'][m
[32m+[m[41m        [m
[32m+[m[32m        params['load_file'] = calc['system-info']['artifact']['file'][m
[32m+[m[32m        params['load_style'] = calc['system-info']['artifact']['format'][m
[32m+[m[32m        params['load_options'] = calc['system-info']['artifact']['load_options'][m
[32m+[m[32m        params['family'] = calc['system-info']['family'][m
[32m+[m[32m        symbols = aslist(calc['system-info']['symbol'])[m
[32m+[m[41m        [m
[32m+[m[32m        params['initial_defect_number'] = calc['point-defects']['numberInitialDefects'][m
[32m+[m[32m        params['defectpair_number'] = calc['point-defects']['numberDefectPairs'][m
[32m+[m[32m        params['allSymbols'] = calc['point-defects']['allSymbols'][m
[32m+[m[41m        [m
[32m+[m[41m        [m
[32m+[m[32m        if int(params['initial_defect_number'])>0: #Thing here for running through all the point defects[m
[32m+[m[32m            for x in range(int(params['pointdefect_number'])):[m
[32m+[m
[32m+[m[32m                calckey = 'initial-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'initial_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'initial_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'initial_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'initial_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'initial_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('initial-defect-type', 'initial-defect-atom-type', 'initial-defect-position', 'initial-defect-dumbbell-vector',[m
[32m+[m[32m                                    'initial-defect-scale')):[m
[32m+[m[32m                    if key2 in calc['point-defects'][calckey]:[m
[32m+[m[32m                        params[key1] = calc['point-defects'][calckey][key2][m
[32m+[m[41m                        [m
[32m+[m[32m        if int(params['defectpair_number'])>0: #Thing here for running through all the point defects[m
[32m+[m[32m            for x in range(int(params['defectpair_number'])):[m
[32m+[m
[32m+[m[32m                calckey = 'start-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'start_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'start_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'start_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'start_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'start_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('start-defect-type', 'start-defect-atom-type', 'start-defect-position', 'start-defect-dumbbell-vector',[m
[32m+[m[32m                                    'start-defect-scale')):[m
[32m+[m[32m                    if key2 in calc['point-defects'][calckey]:[m
[32m+[m[32m                        params[key1] = calc['point-defects'][calckey][key2][m[41m            [m
[32m+[m
[32m+[m[32m        if int(params['defectpair_number'])>0: #Thing here for running through all the point defects[m
[32m+[m[32m            for x in range(int(params['defectpair_number'])):[m
[32m+[m
[32m+[m[32m                calckey = 'end-point-defect-'+str(x)[m
[32m+[m[32m                defect_type_string = 'end_pointdefect_type_'+str(x)[m
[32m+[m[32m                defect_atype_string = 'end_pointdefect_atype_'+str(x)[m
[32m+[m[32m                defect_pos_string = 'end_pointdefect_pos_'+str(x)[m
[32m+[m[32m                defect_dumbell_string = 'end_pointdefect_dumbbell_vect_'+str(x)[m
[32m+[m[32m                defect_scale_string = 'end_pointdefect_scale_'+str(x)[m
[32m+[m[41m                [m
[32m+[m[32m                for key1, key2 in   zip((defect_type_string, defect_atype_string,[m
[32m+[m[32m                                    defect_pos_string, defect_dumbell_string,[m
[32m+[m[32m                                    defect_scale_string),('end-defect-type', 'end-defect-atom-type', 'end-defect-position', 'end-defect-dumbbell-vector',[m
[32m+[m[32m                                    'end-defect-scale')):[m
[32m+[m[32m                    if key2 in calc['point-defects'][calckey]:[m
[32m+[m[32m                        params[key1] = calc['point-defects'][calckey][key2][m[41m   [m
[32m+[m
[32m+[m[32m        if flat is True:[m
[32m+[m[32m            params['a_mult1'] = sizemults['a'][0][m
[32m+[m[32m            params['a_mult2'] = sizemults['a'][1][m
[32m+[m[32m            params['b_mult1'] = sizemults['b'][0][m
[32m+[m[32m            params['b_mult2'] = sizemults['b'][1][m
[32m+[m[32m            params['c_mult1'] = sizemults['c'][0][m
[32m+[m[32m            params['c_mult2'] = sizemults['c'][1][m
[32m+[m[32m            params['symbols'] = ' '.join(symbols)[m
[32m+[m[32m        else:[m
[32m+[m[32m            params['sizemults'] = np.array([sizemults['a'], sizemults['b'], sizemults['c']])[m
[32m+[m[32m            params['symbols'] = symbols[m
[32m+[m[41m        [m
[32m+[m[32m        params['status'] = calc.get('status', 'finished')[m
[32m+[m[32m        params['error'] = calc.get('error', np.nan)[m
[32m+[m[41m        [m
[32m+[m[32m        if full is True and params['status'] == 'finished': #Figuring out storing this info[m
[32m+[m[41m        [m
[32m+[m[32m            params['forward_barrier_energy'] = uc.value_unit(calc['barrier']['forward-barrier'])[m
[32m+[m[32m            params['reverse_barrier_energy'] = uc.value_unit(calc['barrier']['reverse-barrier'])[m
[32m+[m[32m            #params['natoms'] = calc['number-of-atoms'][m
[32m+[m[41m            [m
[32m+[m
[32m+[m[32m            if flat is False:[m
[32m+[m[32m                plot = calc['calculation']['calc-results']['unrelaxed'][m
[32m+[m[32m                unrelaxed_plot = {}[m
[32m+[m[32m                unrelaxed_plot['coordinates'] = uc.value_unit(plot['cooridnates'])[m
[32m+[m[32m                unrelaxed_plot['energy'] = uc.value_unit(plot['energy'])[m
[32m+[m[32m                params['unrelaxed_plot'] = pd.DataFrame(unrelaxed_plot)[m
[32m+[m[32m                plot = calc['calculation']['calc-results']['minimized'][m
[32m+[m[32m                minimizeded_plot = {}[m
[32m+[m[32m                minimizeded_plot['coordinates'] = uc.value_unit(plot['cooridnates'])[m
[32m+[m[32m                minimizeded_plot['energy'] = uc.value_unit(plot['energy'])[m
[32m+[m[32m                params['minimizeded_plot'] = pd.DataFrame(minimizeded_plot)[m
[32m+[m[32m                plot = calc['calculation']['calc-results']['climbed'][m
[32m+[m[32m                climbed_plot = {}[m
[32m+[m[32m                climbed_plot['coordinates'] = uc.value_unit(plot['cooridnates'])[m
[32m+[m[32m                climbed_plot['energy'] = uc.value_unit(plot['energy'])[m
[32m+[m[32m                params['climbed_plot'] = pd.DataFrame(climbed_plot)[m
[32m+[m[32m                plot = calc['calculation']['calc-results']['minimized-and-climbed'][m
[32m+[m[32m                min_and_climb_plot = {}[m
[32m+[m[32m                min_and_climb_plot['coordinates'] = uc.value_unit(plot['cooridnates'])[m
[32m+[m[32m                min_and_climb_plot['energy'] = uc.value_unit(plot['energy'])[m
[32m+[m[32m                params['min_and_climb_plot'] = pd.DataFrame(min_and_climb_plot)[m
[32m+[m[41m                [m
[32m+[m[41m [m
[32m+[m[32m        return params[m
[32m+[m[41m        [m
[32m+[m[41m        [m
\ No newline at end of file[m
[1mdiff --git a/iprPy/record/calculation_point_defect_mobility/__init__.py b/iprPy/record/calculation_point_defect_mobility/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..e137d7a[m
[1m--- /dev/null[m
[1m+++ b/iprPy/record/calculation_point_defect_mobility/__init__.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import division, absolute_import, print_function[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom .CalculationPointDefectMobility import CalculationPointDefectMobility[m
[32m+[m[32m__all__ = ['CalculationPointDefectMobility'][m
\ No newline at end of file[m
[1mdiff --git a/iprPy/record/point_defect_mobility/PointDefectMobility.py b/iprPy/record/point_defect_mobility/PointDefectMobility.py[m
[1mnew file mode 100644[m
[1mindex 0000000..65986cc[m
[1m--- /dev/null[m
[1m+++ b/iprPy/record/point_defect_mobility/PointDefectMobility.py[m
[36m@@ -0,0 +1,65 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import (absolute_import, print_function,[m
[32m+[m[32m                        division, unicode_literals)[m
[32m+[m[32mimport os[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom .. import Record[m
[32m+[m
[32m+[m[32mclass PointDefect(Record):[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def contentroot(self):[m
[32m+[m[32m        """str: The root element of the content"""[m
[32m+[m[32m        return 'point-defect'[m
[32m+[m[41m    [m
[32m+[m[32m    @property[m
[32m+[m[32m    def schema(self):[m
[32m+[m[32m        """[m
[32m+[m[32m        str: The absolute directory path to the .xsd file associated with the[m
[32m+[m[32m             record style.[m
[32m+[m[32m        """[m
[32m+[m[32m        return os.path.join(self.directory, 'record-point-defect.xsd')[m
[32m+[m[41m    [m
[32m+[m[32m    def todict(self, full=True, flat=False):[m
[32m+[m[32m        """[m
[32m+[m[32m        Converts the structured content to a simpler dictionary.[m
[32m+[m[41m        [m
[32m+[m[32m        Parameters[m
[32m+[m[32m        ----------[m
[32m+[m[32m        full : bool, optional[m
[32m+[m[32m            Flag used by the calculation records.  A True value will include[m
[32m+[m[32m            terms for both the calculation's input and results, while a value[m
[32m+[m[32m            of False will only include input terms (Default is True).[m
[32m+[m[32m        flat : bool, optional[m
[32m+[m[32m            Flag affecting the format of the dictionary terms.  If True, the[m
[32m+[m[32m            dictionary terms are limited to having only str, int, and float[m
[32m+[m[32m            values, which is useful for comparisons.  If False, the term[m
[32m+[m[32m            values can be of any data type, which is convenient for analysis.[m
[32m+[m[32m            (Default is False).[m
[32m+[m[41m            [m
[32m+[m[32m        Returns[m
[32m+[m[32m        -------[m
[32m+[m[32m        dict[m
[32m+[m[32m            A dictionary representation of the record's content.[m
[32m+[m[32m        """[m
[32m+[m[41m        [m
[32m+[m[32m        ptd = self.content[self.contentroot][m
[32m+[m[32m        params = {}[m
[32m+[m[32m        params['key'] = ptd['key'][m
[32m+[m[32m        params['id'] = ptd['id'][m
[32m+[m[32m        params['family'] = ptd['system-family'][m
[32m+[m[41m        [m
[32m+[m[32m        params['ptd_type'] = [][m
[32m+[m[32m        params['pos'] = [][m
[32m+[m[32m        params['atype'] = [][m
[32m+[m[32m        params['db_vect'] = [][m
[32m+[m[32m        params['scale'] = [][m
[32m+[m[32m        for cp in ptd.iteraslist('calculation-parameter'):[m
[32m+[m[32m            params['ptd_type'].append(cp.get('ptd_type', None))[m
[32m+[m[32m            params['pos'].append(cp.get('pos', None))[m
[32m+[m[32m            params['atype'].append(cp.get('atype', None))[m
[32m+[m[32m            params['db_vect'].append(cp.get('db_vect', None))[m
[32m+[m[32m            params['scale'].append(cp.get('scale', None))[m
[32m+[m[41m        [m
[32m+[m[32m        return params[m
\ No newline at end of file[m
[1mdiff --git a/iprPy/record/point_defect_mobility/__init__.py b/iprPy/record/point_defect_mobility/__init__.py[m
[1mnew file mode 100644[m
[1mindex 0000000..5d41a64[m
[1m--- /dev/null[m
[1m+++ b/iprPy/record/point_defect_mobility/__init__.py[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m# Standard Python libraries[m
[32m+[m[32mfrom __future__ import division, absolute_import, print_function[m
[32m+[m
[32m+[m[32m# iprPy imports[m
[32m+[m[32mfrom .PointDefectMobility import PointDefectMobility[m
[32m+[m[32m__all__ = ['PointDefectMobility'][m
\ No newline at end of file[m
[1mdiff --git a/iprPy/record/point_defect_mobility/record-point-defect-mobility.xsd b/iprPy/record/point_defect_mobility/record-point-defect-mobility.xsd[m
[1mnew file mode 100644[m
[1mindex 0000000..6f7fb7d[m
[1m--- /dev/null[m
[1m+++ b/iprPy/record/point_defect_mobility/record-point-defect-mobility.xsd[m
[36m@@ -0,0 +1,6 @@[m
[32m+[m[32m<?xml version="1.0" encoding="UTF-8" standalone="no"?>[m
[32m+[m[32m<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified"[m
[32m+[m[32m    elementFormDefault="unqualified">[m
[32m+[m
[32m+[m[32m    <xsd:element name="point-defect" type="xsd:anyType"/>[m
[32m+[m[32m</xsd:schema>[m
